{"version":3,"file":"js/chunks/src_RoundCubeWrapper_vue-e7911c8d862a07f4d50b.js","mappings":"qKAAA,I,gDC2BA,MC3BgP,GD2BpNA,EAAAA,EAAAA,IAAiB,CAC3CC,OAAQ,mBACRC,MAAO,CACLC,iBAAkB,KAClBC,WAAY,CAAEC,KAAMC,QAASC,SAAS,GACtCC,YAAa,CAAEH,KAAMC,QAASC,SAAS,GACvCE,MAAO,CAAEF,QAASA,KAAA,CAClBG,MAAO,WAGTC,MAAO,CAAC,gBAAiB,gBAAiB,iBAAkB,SAC5DC,KAAAA,CAAMC,EAAYC,GAKqB,IALnB,OAAEC,EAAM,KAAEC,GAKSF,EAEzC,MAAMZ,EAAQW,EEMRI,EAAa,YAkCbC,GAAUC,EAAAA,EAAAA,KAAI,IAEpBC,EAAAA,EAAAA,IAAMF,GAAUG,GAAUL,EAAK,iBAAkBK,KAEjD,MAAMC,GAAcC,EAAAA,EAAAA,KAAS,IAAO,IAAIC,gBAAgBtB,EAAMO,OAAQgB,aAEhEC,GAAoBH,EAAAA,EAAAA,KAAS,IAC1BrB,EAAMC,iBAAmB,KAAOmB,EAAYD,MAAQ,IAAMC,EAAYD,MAAQ,MAKjFM,GAAiBR,EAAAA,EAAAA,IAAIO,EAAkBL,OAIvCO,GAAkBT,EAAAA,EAAAA,IAAIO,EAAkBL,OAExCQ,GAAUN,EAAAA,EAAAA,KAAS,IAAMO,EAAAA,EAAU,YAEzCV,EAAAA,EAAAA,IAAME,GAAcS,IACdL,EAAkBL,QAAUO,EAAgBP,OAC9CW,EAAAA,EAAOC,MAAM,yBAA0B,CAAEC,QAASR,EAAkBL,MAAOc,QAASP,EAAgBP,QACpGH,EAAQG,OAAQ,EAChBM,EAAeN,MAAQK,EAAkBL,OAEzCW,EAAAA,EAAOC,MAAM,6BAA8B,CAAEC,QAASR,EAAkBL,MAAOc,QAASP,EAAgBP,OAC1G,IAGF,MAAMe,EAAc,IAEpB,IAEIC,EAFAC,EAAa,EAIjB,MAAMC,GAAYpB,EAAAA,EAAAA,IAAyB,MACrCqB,GAAkBrB,EAAAA,EAAAA,IAAyB,MAC3CsB,GAAetB,EAAAA,EAAAA,IAAyB,MACxCuB,GAAgBvB,EAAAA,EAAAA,IAA4B,MAClD,IAAIwB,EAEJ,MAAMC,EAAgBC,IAAuC,IAAtC,MAAEC,EAAK,OAAEC,GAAyBF,EACvD,IAAKH,EAAcrB,MACjB,OAEF,MAAM2B,EAASN,EAAcrB,MAC7B2B,EAAOC,MAAMH,MAAQA,EAAQ,KAC7BE,EAAOC,MAAMF,OAASA,EAAS,IAAI,EAG/BG,EAAiB,IAAIC,gBAAgBC,IACzC,IAAK,MAAMC,KAASD,EACdC,EAAMC,SAAWX,EAIjBzC,EAAME,YAAciD,EAAMC,SAAWf,EAAUlB,OACjDuB,EAAcS,EAAME,aAJpBvC,EAAK,gBAAiBqC,EAM1B,IAGIG,EAAkB,IAAIC,kBAAkBL,IAC5CpB,EAAAA,EAAO0B,KAAK,oBAAqB,CAAEN,YACnC,MAAMJ,EAASN,EAAcrB,MAC7BsC,EAAWX,EAAO,IAGdY,EAAaC,IACjBrB,EAAgBnB,MAAOyC,UAAUC,OAAO,UAAU,GAClD/C,EAAK,QAAS,CACZ6C,MAAOA,aAAiBG,MAAQH,EAAQ,IAAIG,MAAM,kBAAmB,CAAEC,MAAOJ,IAC9EK,MAAMC,EAAAA,EAAAA,IACJrC,EAAAA,EACA,gRAGA,CACEsC,aAAcC,OAAOC,SAASC,SAAW,KAAOF,OAAOC,SAASE,KAChEC,UAAWvE,EAAMC,kBAAoB,GACrCc,gBAGJ,EAGE0C,EAAcX,IAClB,MAAM0B,EAAe1B,EAAO2B,cACtBC,EAAiB5B,EAAO6B,gBAC9BjD,EAAgBP,MAAQqD,EAAaJ,SAASQ,KAC9C,MAAMC,EAASL,EAAaJ,SAASS,OAC/BtE,EAAQuE,OAAOC,YAAa,IAAIzD,gBAAgBuD,GAAS3B,WAC/DpC,EAAK,gBAAiB,CACpBP,QACAuC,SACAqB,OAAQK,EACRQ,SAAUN,GACV,EAwCEO,EAAmBA,KAEvB,GADA9C,OAAY+C,EACPlE,EAAQG,MAAb,CAGAiB,IACA,IACyBI,EAAcrB,MAAOsD,cAAeO,SACxCG,cAAc,YAC/BrD,EAAAA,EAAOC,MAAM,0CAA6CG,EAAcE,EAAc,OACtFI,EAAcrB,MAAOiE,cAAc,IAAIC,MAAM,UAE7ClD,EAAYmD,WAAWL,EAAkB/C,EAE7C,CAAE,MAAOyB,GACP7B,EAAAA,EAAO6B,MAAM,mCAAoC,CAAEA,UACnDD,EAAUC,EACZ,CAbA,CAaA,EFSF,OENA4B,EAAAA,EAAAA,KAAc,KACZvE,EAAQG,OAAQ,EAChBM,EAAeN,MAAQK,EAAkBL,KAAK,KAGhDD,EAAAA,EAAAA,KAAM,IAAMlB,EAAME,aAAaiB,IAC7B,GAAIA,EAAO,CAGT,MAAM2B,EAASN,EAAcrB,MACzB2B,IACErB,EAAeN,QAAUK,EAAkBL,MAC7CM,EAAeN,MAAQK,EAAkBL,MAChC2B,EAAO2B,gBAChB3B,EAAO2B,cAAcL,SAASQ,KAAOpD,EAAkBL,OAG7D,MAGFqE,EAAAA,EAAAA,KAAU,KACHrD,IACHA,EAAYmD,WAAWL,EAAkB/C,IAE3Cc,EAAeyC,QAAQpD,EAAUlB,MAAO,KAG1CuE,EAAAA,EAAAA,KAAgB,KACd1C,EAAe2C,aACfrC,EAAgBqC,YAAY,IAG9B9E,EAAa,CACXa,kBACAkE,aAAcpD,IF5BT,CAAEqD,OAAO,EAAK9E,aAAYf,QAAOc,OAAME,UAASI,cAAaI,oBAAmBC,iBAAgBC,kBAAiBC,UAASO,cAAaE,aAAYD,YAAWE,YAAWC,kBAAiBC,eAAcC,gBAAeC,aAAYC,gBAAeM,iBAAgBM,kBAAiBI,YAAWD,aAAYqC,YE/D7RA,KAClBhE,EAAAA,EAAOC,MAAM,kBACb,MAAMe,EAASN,EAAcrB,MACvBqD,EAAe1B,GAAQ2B,cAC7B,IAAK3B,IAAW0B,EACd,OAGF,IAAIE,EADJ1D,EAAQG,OAAQ,EAEhB,IACEuD,EAAiB5B,EAAO6B,eAC1B,CAAE,MAAOhB,GAGP,OAFA7B,EAAAA,EAAO6B,MAAM,mCAAoC,CAAEA,eACnDD,EAAUC,EAEZ,CACI3D,EAAMM,aC1KgByF,KAC1B,MAAMC,EAA+BD,EAAItB,cACnCwB,EAAgBD,EAAYhB,SAE5BkB,EAAOF,EAAYG,OAAQC,IAAIF,KACrC,GAAIA,EAAKG,SAAS,WAEhBJ,EAAcK,iBAAiB,kBAAkBC,SAAQC,GAAMA,EAAGC,gBAC7D,GAAIP,EAAKG,SAAS,WAEvBJ,EAAcK,iBAAiB,mCAAmCC,SAAQC,GAAMA,EAAGC,gBAC9E,GAAIP,EAAKG,SAAS,SAAU,CAMjC,MAAMK,EAAiCT,EAAcd,cAAc,eAC7DwB,EAAgBV,EAAcd,cAAc,YAAayB,wBAAwB/D,OAEjFgE,EAAgB,GACtB,IAAIC,EAFkBC,SAASL,EAAkB3D,MAAMiE,KAEhBL,EACvCV,EAAcd,cAAc,YAAasB,SACpCC,EAAkBvB,cAAc,cACnC2B,GAAoBD,GAEtBH,EAAkB3D,MAAMiE,IAAMF,EAAmB,KACjDb,EAAcd,cAAc,kCAAmCsB,SAC9DR,EAAcd,cAAc,YAA6BpC,MAAM,iBAAmB,EACnFkD,EAAcd,cAAc,kBAAmBsB,QACjD,GD6IEQ,CAAcnE,GAEZ9C,EAAME,YACRwC,EAAcL,EAAUlB,MAAOyF,yBAEjCnE,EAAaiC,GAAgBwC,KAC7BpF,EAAAA,EAAOC,MAAM,cAAe,CAAEU,eAC1BA,IACFO,EAAeyC,QAAQhD,GACvBa,EAAgBmC,QAAQhD,EAAY,CAAE0E,WAAW,EAAMC,SAAS,KAElE9E,EAAgBnB,MAAOyC,UAAUC,OAAO,UAAU,GAClD/B,EAAAA,EAAOC,MAAM,gBAAiB,CAC5Be,SACAsB,SAAUI,EAAaJ,WAEzBX,EAAWX,GACX9B,EAAQG,OAAQ,CAAK,EF6BuS8D,mBAAkBrD,QAAOA,EAAAA,EACvV,IIvOA,SAXgB,E,SAAA,GACd,GLTW,WAAkB,IAAIyF,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAGE,EAAOJ,EAAIG,MAAME,YAAY,OAAOH,EAAG,MAAM,CAACtG,IAAI,YAAY0G,MAAMF,EAAO7F,QAAU,cAAc,CAAC2F,EAAG,MAAM,CAACtG,IAAI,kBAAkB2G,YAAY,qBAAqBP,EAAIQ,GAAG,KAAKN,EAAG,MAAM,CAACtG,IAAI,eAAe0G,MAAMF,EAAO7F,QAAU,kBAAkB,CAAC2F,EAAG,SAAS,CAACtG,IAAI,gBAAgB6G,MAAM,CAAC,GAAKL,EAAO9F,QAAQ,IAAM8F,EAAOhG,eAAe,KAAOgG,EAAO7F,SAASmG,GAAG,CAAC,KAAON,EAAO3B,kBACrb,GACsB,IKUpB,EACA,KACA,WACA,MAI8B,O","sources":["webpack://mail_roundcube/./src/RoundCubeWrapper.vue","webpack://mail_roundcube/./src/RoundCubeWrapper.vue?d61d","webpack://mail_roundcube/./src/RoundCubeWrapper.vue?740d","webpack://mail_roundcube/RoundCubeWrapper.vue","webpack://mail_roundcube/./src/roundcube.ts","webpack://mail_roundcube/./src/RoundCubeWrapper.vue?8426"],"sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c,_setup=_vm._self._setupProxy;return _c('div',{ref:\"container\",class:_setup.appName + '-container'},[_c('div',{ref:\"loaderContainer\",staticClass:\"loader-container\"}),_vm._v(\" \"),_c('div',{ref:\"frameWrapper\",class:_setup.appName + '-frame-wrapper'},[_c('iframe',{ref:\"externalFrame\",attrs:{\"id\":_setup.frameId,\"src\":_setup.iFrameLocation,\"name\":_setup.appName},on:{\"load\":_setup.loadHandler}})])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import { defineComponent as _defineComponent } from 'vue'\nimport { appName } from './config.ts'\nimport { translate as t } from '@nextcloud/l10n'\nimport { hideTopLine as removeTopLine } from './roundcube.ts'\nimport {\n  computed,\n  onBeforeMount,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  watch,\n} from 'vue'\nimport logger from './logger.ts'\n\ninterface IFrameLoadedEventData {\n  query: Record<string, string>,\n  iFrame: HTMLIFrameElement,\n  window: Window,\n  document: Document,\n}\n\ninterface ErrorEventData {\n  error: Error,\n  hint: string,\n}\n\n\nexport default /*#__PURE__*/_defineComponent({\n  __name: 'RoundCubeWrapper',\n  props: {\n    externalLocation: null,\n    fullScreen: { type: Boolean, default: true },\n    hideTopLine: { type: Boolean, default: true },\n    query: { default: () => ({\n    _task: 'mail',\n  }) }\n  },\n  emits: [\"iframe-loaded\", \"iframe-resize\", \"update-loading\", \"error\"],\n  setup(__props: any, { expose, emit }: { emit: ({\n  (event: 'iframe-loaded', eventData: IFrameLoadedEventData): void,\n  (event: 'iframe-resize', eventData: ResizeObserverEntry): void,\n  (event: 'update-loading', loading: boolean): void,\n  (event: 'error', eventData: ErrorEventData): void,\n}), expose: any, slots: any, attrs: any }) {\n\nconst props = __props as { externalLocation: string, fullScreen: boolean, hideTopLine: boolean, query: Record<string, string> };\n\nconst wrappedApp = 'RoundCube'\n\n\n\n\n\nconst loading = ref(true)\n\nwatch(loading, (value) => emit('update-loading', value))\n\nconst queryString = computed(() => (new URLSearchParams(props.query)).toString())\n\nconst requestedLocation = computed(() => {\n  return props.externalLocation + '/' + (queryString.value ? '?' + queryString.value : '')\n})\n/**\n * Value of src attribute of iframe.\n */\nconst iFrameLocation = ref(requestedLocation.value)\n/**\n * Actual location which in general is different from the src attribute.\n */\nconst currentLocation = ref(requestedLocation.value)\n\nconst frameId = computed(() => appName + '-frame')\n\nwatch(queryString, (_value) => {\n  if (requestedLocation.value !== currentLocation.value) {\n    logger.debug('TRIGGER IFRAME REFRESH', { request: requestedLocation.value, current: currentLocation.value })\n    loading.value = true\n    iFrameLocation.value = requestedLocation.value\n  } else {\n    logger.debug('NOT CHANGING IFRAME SOURCE', { request: requestedLocation.value, current: currentLocation.value })\n  }\n})\n\nconst loadTimeout = 1000 // 1 second\n\nlet timerCount = 0\n\nlet loadTimer: undefined|ReturnType<typeof setTimeout>\n\nconst container = ref<null|HTMLDivElement>(null)\nconst loaderContainer = ref<null|HTMLDivElement>(null)\nconst frameWrapper = ref<null|HTMLDivElement>(null)\nconst externalFrame = ref<null|HTMLIFrameElement>(null)\nlet iFrameBody: undefined | HTMLBodyElement\n\nconst setIFrameSize = ({ width, height }: DOMRectReadOnly) => {\n  if (!externalFrame.value) {\n    return\n  }\n  const iFrame = externalFrame.value\n  iFrame.style.width = width + 'px'\n  iFrame.style.height = height + 'px'\n}\n\nconst resizeObserver = new ResizeObserver((entries) => {\n  for (const entry of entries) {\n    if (entry.target === iFrameBody) {\n      emit('iframe-resize', entry)\n      continue\n    }\n    if (props.fullScreen && entry.target === container.value) {\n      setIFrameSize(entry.contentRect)\n    }\n  }\n})\n\nconst contentObserver = new MutationObserver((entries) => {\n  logger.info('MUTATION OBSERVED', { entries })\n  const iFrame = externalFrame.value!\n  emitLoaded(iFrame)\n})\n\nconst emitError = (error: unknown) => {\n  loaderContainer.value!.classList.toggle('fading', true)\n  emit('error', {\n    error: error instanceof Error ? error : new Error('Non-error error', { cause: error }),\n    hint: t(\n      appName,\n      `Unable to access the contents of the wrapped {wrappedApp} instance.\nThis may be caused by cross-domain access restrictions.\nPlease check that your Nextcloud instance ({nextcloudUrl}) and the wrapped {wrappedApp} instance ({iFrameUrl}) are served from the same domain.`,\n      {\n        nextcloudUrl: window.location.protocol + '//' + window.location.host,\n        iFrameUrl: props.externalLocation || '',\n        wrappedApp,\n      },\n    ),\n  })\n}\n\nconst emitLoaded = (iFrame: HTMLIFrameElement) => {\n  const iFrameWindow = iFrame.contentWindow!\n  const iFrameDocument = iFrame.contentDocument!\n  currentLocation.value = iFrameWindow.location.href\n  const search = iFrameWindow.location.search\n  const query = Object.fromEntries((new URLSearchParams(search)).entries())\n  emit('iframe-loaded', {\n    query,\n    iFrame,\n    window: iFrameWindow,\n    document: iFrameDocument,\n  })\n}\n\nconst loadHandler = () => {\n  logger.debug('GOT LOAD EVENT')\n  const iFrame = externalFrame.value\n  const iFrameWindow = iFrame?.contentWindow\n  if (!iFrame || !iFrameWindow) {\n    return\n  }\n  loading.value = true // if not already set ...\n  let iFrameDocument: Document|null\n  try {\n    iFrameDocument = iFrame.contentDocument\n  } catch (error: unknown) {\n    logger.error('UNABLE TO ACCESS IFRAME CONTENTS', { error })\n    emitError(error)\n    return\n  }\n  if (props.hideTopLine) {\n    removeTopLine(iFrame)\n  }\n  if (props.fullScreen) {\n    setIFrameSize(container.value!.getBoundingClientRect())\n  }\n  iFrameBody = iFrameDocument?.body as undefined|HTMLBodyElement\n  logger.debug('IFRAME BODY', { iFrameBody })\n  if (iFrameBody) {\n    resizeObserver.observe(iFrameBody)\n    contentObserver.observe(iFrameBody, { childList: true, subtree: true })\n  }\n  loaderContainer.value!.classList.toggle('fading', true)\n  logger.debug('IFRAME IS NOW', {\n    iFrame,\n    location: iFrameWindow.location,\n  })\n  emitLoaded(iFrame)\n  loading.value = false\n}\n\nconst loadTimerHandler = () => {\n  loadTimer = undefined\n  if (!loading.value) {\n    return\n  }\n  timerCount++\n  try {\n    const iFrameContents = externalFrame.value!.contentWindow!.document\n    if (iFrameContents.querySelector('#layout')) {\n      logger.debug('ROUNDCUBE: LOAD EVENT FROM TIMER AFTER ' + (loadTimeout * timerCount) + ' ms')\n      externalFrame.value!.dispatchEvent(new Event('load'))\n    } else {\n      loadTimer = setTimeout(loadTimerHandler, loadTimeout)\n    }\n  } catch (error: unknown) {\n    logger.error('UNABLE TO ACCESS IFRAME CONTENTS', { error })\n    emitError(error)\n  }\n}\n\nonBeforeMount(() => {\n  loading.value = true\n  iFrameLocation.value = requestedLocation.value\n})\n\nwatch(() => props.fullScreen, (value) => {\n  if (value) {\n    // if this mutation really happens we trigger an iframe reload by\n    // touching its src attribute\n    const iFrame = externalFrame.value\n    if (iFrame) {\n      if (iFrameLocation.value !== requestedLocation.value) {\n        iFrameLocation.value = requestedLocation.value\n      } else if (iFrame.contentWindow) {\n        iFrame.contentWindow.location.href = requestedLocation.value\n      }\n    }\n  }\n})\n\nonMounted(() => {\n  if (!loadTimer) {\n    loadTimer = setTimeout(loadTimerHandler, loadTimeout)\n  }\n  resizeObserver.observe(container.value!)\n})\n\nonBeforeUnmount(() => {\n  resizeObserver.disconnect()\n  contentObserver.disconnect()\n})\n\nexpose({\n  currentLocation,\n  redaxoIFrame: externalFrame,\n})\n\n\nreturn { __sfc: true,wrappedApp, props, emit, loading, queryString, requestedLocation, iFrameLocation, currentLocation, frameId, loadTimeout, timerCount, loadTimer, container, loaderContainer, frameWrapper, externalFrame, iFrameBody, setIFrameSize, resizeObserver, contentObserver, emitError, emitLoaded, loadHandler, loadTimerHandler, appName }\n}\n\n})","import mod from \"-!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??clonedRuleSet-6.use[1]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./RoundCubeWrapper.vue?vue&type=script&setup=true&lang=ts\"; export default mod; export * from \"-!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??clonedRuleSet-6.use[1]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./RoundCubeWrapper.vue?vue&type=script&setup=true&lang=ts\"","<!--\n - @copyright Copyright (c) 2025 Claus-Justus Heine <himself@claus-justus-heine.de>\n - @author Claus-Justus Heine <himself@claus-justus-heine.de>\n - @license AGPL-3.0-or-later\n -\n - This program is free software: you can redistribute it and/or modify\n - it under the terms of the GNU Affero General Public License as\n - published by the Free Software Foundation, either version 3 of the\n - License, or (at your option) any later version.\n -\n - This program is distributed in the hope that it will be useful,\n - but WITHOUT ANY WARRANTY; without even the implied warranty of\n - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n - GNU Affero General Public License for more details.\n -\n - You should have received a copy of the GNU Affero General Public License\n - along with this program. If not, see <http://www.gnu.org/licenses/>.\n -->\n<template>\n  <div ref=\"container\"\n       :class=\"appName + '-container'\"\n  >\n    <div ref=\"loaderContainer\"\n         class=\"loader-container\"\n    />\n    <div ref=\"frameWrapper\"\n         :class=\"appName + '-frame-wrapper'\"\n    >\n      <iframe :id=\"frameId\"\n              ref=\"externalFrame\"\n              :src=\"iFrameLocation\"\n              :name=\"appName\"\n              @load=\"loadHandler\"\n      />\n    </div>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { appName } from './config.ts'\nimport { translate as t } from '@nextcloud/l10n'\nimport { hideTopLine as removeTopLine } from './roundcube.ts'\nimport {\n  computed,\n  onBeforeMount,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  watch,\n} from 'vue'\nimport logger from './logger.ts'\n\nconst wrappedApp = 'RoundCube'\n\nconst props = withDefaults(defineProps<{\n  externalLocation: string,\n  fullScreen?: boolean,\n  hideTopLine?: boolean,\n  query?: Record<string, string>,\n}>(), {\n  fullScreen: true,\n  hideTopLine: true,\n  query: () => ({\n    _task: 'mail',\n  }),\n})\n\ninterface IFrameLoadedEventData {\n  query: Record<string, string>,\n  iFrame: HTMLIFrameElement,\n  window: Window,\n  document: Document,\n}\n\ninterface ErrorEventData {\n  error: Error,\n  hint: string,\n}\n\nconst emit = defineEmits<{\n  (event: 'iframe-loaded', eventData: IFrameLoadedEventData): void,\n  (event: 'iframe-resize', eventData: ResizeObserverEntry): void,\n  (event: 'update-loading', loading: boolean): void,\n  (event: 'error', eventData: ErrorEventData): void,\n}>()\n\nconst loading = ref(true)\n\nwatch(loading, (value) => emit('update-loading', value))\n\nconst queryString = computed(() => (new URLSearchParams(props.query)).toString())\n\nconst requestedLocation = computed(() => {\n  return props.externalLocation + '/' + (queryString.value ? '?' + queryString.value : '')\n})\n/**\n * Value of src attribute of iframe.\n */\nconst iFrameLocation = ref(requestedLocation.value)\n/**\n * Actual location which in general is different from the src attribute.\n */\nconst currentLocation = ref(requestedLocation.value)\n\nconst frameId = computed(() => appName + '-frame')\n\nwatch(queryString, (_value) => {\n  if (requestedLocation.value !== currentLocation.value) {\n    logger.debug('TRIGGER IFRAME REFRESH', { request: requestedLocation.value, current: currentLocation.value })\n    loading.value = true\n    iFrameLocation.value = requestedLocation.value\n  } else {\n    logger.debug('NOT CHANGING IFRAME SOURCE', { request: requestedLocation.value, current: currentLocation.value })\n  }\n})\n\nconst loadTimeout = 1000 // 1 second\n\nlet timerCount = 0\n\nlet loadTimer: undefined|ReturnType<typeof setTimeout>\n\nconst container = ref<null|HTMLDivElement>(null)\nconst loaderContainer = ref<null|HTMLDivElement>(null)\nconst frameWrapper = ref<null|HTMLDivElement>(null)\nconst externalFrame = ref<null|HTMLIFrameElement>(null)\nlet iFrameBody: undefined | HTMLBodyElement\n\nconst setIFrameSize = ({ width, height }: DOMRectReadOnly) => {\n  if (!externalFrame.value) {\n    return\n  }\n  const iFrame = externalFrame.value\n  iFrame.style.width = width + 'px'\n  iFrame.style.height = height + 'px'\n}\n\nconst resizeObserver = new ResizeObserver((entries) => {\n  for (const entry of entries) {\n    if (entry.target === iFrameBody) {\n      emit('iframe-resize', entry)\n      continue\n    }\n    if (props.fullScreen && entry.target === container.value) {\n      setIFrameSize(entry.contentRect)\n    }\n  }\n})\n\nconst contentObserver = new MutationObserver((entries) => {\n  logger.info('MUTATION OBSERVED', { entries })\n  const iFrame = externalFrame.value!\n  emitLoaded(iFrame)\n})\n\nconst emitError = (error: unknown) => {\n  loaderContainer.value!.classList.toggle('fading', true)\n  emit('error', {\n    error: error instanceof Error ? error : new Error('Non-error error', { cause: error }),\n    hint: t(\n      appName,\n      `Unable to access the contents of the wrapped {wrappedApp} instance.\nThis may be caused by cross-domain access restrictions.\nPlease check that your Nextcloud instance ({nextcloudUrl}) and the wrapped {wrappedApp} instance ({iFrameUrl}) are served from the same domain.`,\n      {\n        nextcloudUrl: window.location.protocol + '//' + window.location.host,\n        iFrameUrl: props.externalLocation || '',\n        wrappedApp,\n      },\n    ),\n  })\n}\n\nconst emitLoaded = (iFrame: HTMLIFrameElement) => {\n  const iFrameWindow = iFrame.contentWindow!\n  const iFrameDocument = iFrame.contentDocument!\n  currentLocation.value = iFrameWindow.location.href\n  const search = iFrameWindow.location.search\n  const query = Object.fromEntries((new URLSearchParams(search)).entries())\n  emit('iframe-loaded', {\n    query,\n    iFrame,\n    window: iFrameWindow,\n    document: iFrameDocument,\n  })\n}\n\nconst loadHandler = () => {\n  logger.debug('GOT LOAD EVENT')\n  const iFrame = externalFrame.value\n  const iFrameWindow = iFrame?.contentWindow\n  if (!iFrame || !iFrameWindow) {\n    return\n  }\n  loading.value = true // if not already set ...\n  let iFrameDocument: Document|null\n  try {\n    iFrameDocument = iFrame.contentDocument\n  } catch (error: unknown) {\n    logger.error('UNABLE TO ACCESS IFRAME CONTENTS', { error })\n    emitError(error)\n    return\n  }\n  if (props.hideTopLine) {\n    removeTopLine(iFrame)\n  }\n  if (props.fullScreen) {\n    setIFrameSize(container.value!.getBoundingClientRect())\n  }\n  iFrameBody = iFrameDocument?.body as undefined|HTMLBodyElement\n  logger.debug('IFRAME BODY', { iFrameBody })\n  if (iFrameBody) {\n    resizeObserver.observe(iFrameBody)\n    contentObserver.observe(iFrameBody, { childList: true, subtree: true })\n  }\n  loaderContainer.value!.classList.toggle('fading', true)\n  logger.debug('IFRAME IS NOW', {\n    iFrame,\n    location: iFrameWindow.location,\n  })\n  emitLoaded(iFrame)\n  loading.value = false\n}\n\nconst loadTimerHandler = () => {\n  loadTimer = undefined\n  if (!loading.value) {\n    return\n  }\n  timerCount++\n  try {\n    const iFrameContents = externalFrame.value!.contentWindow!.document\n    if (iFrameContents.querySelector('#layout')) {\n      logger.debug('ROUNDCUBE: LOAD EVENT FROM TIMER AFTER ' + (loadTimeout * timerCount) + ' ms')\n      externalFrame.value!.dispatchEvent(new Event('load'))\n    } else {\n      loadTimer = setTimeout(loadTimerHandler, loadTimeout)\n    }\n  } catch (error: unknown) {\n    logger.error('UNABLE TO ACCESS IFRAME CONTENTS', { error })\n    emitError(error)\n  }\n}\n\nonBeforeMount(() => {\n  loading.value = true\n  iFrameLocation.value = requestedLocation.value\n})\n\nwatch(() => props.fullScreen, (value) => {\n  if (value) {\n    // if this mutation really happens we trigger an iframe reload by\n    // touching its src attribute\n    const iFrame = externalFrame.value\n    if (iFrame) {\n      if (iFrameLocation.value !== requestedLocation.value) {\n        iFrameLocation.value = requestedLocation.value\n      } else if (iFrame.contentWindow) {\n        iFrame.contentWindow.location.href = requestedLocation.value\n      }\n    }\n  }\n})\n\nonMounted(() => {\n  if (!loadTimer) {\n    loadTimer = setTimeout(loadTimerHandler, loadTimeout)\n  }\n  resizeObserver.observe(container.value!)\n})\n\nonBeforeUnmount(() => {\n  resizeObserver.disconnect()\n  contentObserver.disconnect()\n})\n\ndefineExpose({\n  currentLocation,\n  redaxoIFrame: externalFrame,\n})\n\n</script>\n<style scoped lang=\"scss\">\n.#{$roundCubeAppName}-container {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: wrap;\n  justify-content: center;\n  align-items: stretch;\n  align-content: stretch;\n  height: 100%;\n  .loader-container {\n    background-image: url('../img/loader.gif');\n    background-repeat: no-repeat;\n    background-position: center;\n    z-index:10;\n    width:100%;\n    height:100%;\n    position:absolute;\n    transition: visibility 1s, opacity 1s;\n    &.fading {\n      opacity: 0;\n      visibility: hidden;\n    }\n  }\n  * {\n    flex-grow: 10;\n    max-width: 100%;\n    max-height: 100%;\n  }\n}\n</style>\n","/**\n * Nextcloud RoundCube App.\n *\n * @author Claus-Justus Heine\n * @copyright 2020-2025 Claus-Justus Heine <himself@claus-justus-heine.de>\n *\n * Nextcloud RoundCube App is free software: you can redistribute it and/or\n * modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * Nextcloud RoundCube App is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * AFFERO GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU Affero General Public\n * License along with Nextcloud RoundCube App. If not, see\n * <http://www.gnu.org/licenses/>.\n */\n\ntype RoundCubeWindow = Window & {\n  rcmail?: {\n    env: {\n      skin: string,\n    },\n  },\n}\n\n/**\n * @param rcf RoundCubeFrame.\n */\nexport const hideTopLine = (rcf: HTMLIFrameElement) => {\n  const frameWindow: RoundCubeWindow = rcf.contentWindow!;\n  const frameDocument = frameWindow.document!;\n\n  const skin = frameWindow.rcmail!.env.skin;\n  if (skin.includes('classic')) {\n    // just remove the logout button\n    frameDocument.querySelectorAll('.button-logout').forEach(el => el.remove());\n  } else if (skin.includes('elastic')) {\n    // just remove the logout button\n    frameDocument.querySelectorAll(':scope .special-buttons .logout').forEach(el => el.remove());\n  } else if (skin.includes('larry')) {\n    // User shouldn't be able to logout from rc, but from outer app:\n    // 1. #topline has a logout button which we don't want, so remove it and\n    // adjust the top attribute of #mainscreen. Reduce height if no toolbar.\n    // 2. Also remove button to show/hide the #topline and adjust the #taskbar.\n    // 3. Remove other logout buttons.\n    const mainScreenElement: HTMLElement = frameDocument.querySelector('#mainscreen')!;\n    const toplineHeight = frameDocument.querySelector('#topline')!.getBoundingClientRect().height;\n    const mainscreenTop = parseInt(mainScreenElement.style.top);\n    const toolbarHeight = 40;\n    let newMainscreenTop = mainscreenTop - toplineHeight;\n    frameDocument.querySelector('#topline')!.remove(); // [1]\n    if (!mainScreenElement.querySelector('.toolbar')) {\n      newMainscreenTop -= toolbarHeight;\n    }\n    mainScreenElement.style.top = newMainscreenTop + 'px'; // [1]\n    frameDocument.querySelector(':scope #taskbar .minmodetoggle')!.remove(); // [2]\n    (frameDocument.querySelector('#taskbar')! as HTMLElement).style['padding-right'] = 0; // [2]\n    frameDocument.querySelector('.button-logout')!.remove(); // [3]\n  }\n};\n","import { render, staticRenderFns } from \"./RoundCubeWrapper.vue?vue&type=template&id=586249c2&scoped=true\"\nimport script from \"./RoundCubeWrapper.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./RoundCubeWrapper.vue?vue&type=script&setup=true&lang=ts\"\nimport style0 from \"./RoundCubeWrapper.vue?vue&type=style&index=0&id=586249c2&prod&scoped=true&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"586249c2\",\n  null\n  \n)\n\nexport default component.exports"],"names":["_defineComponent","__name","props","externalLocation","fullScreen","type","Boolean","default","hideTopLine","query","_task","emits","setup","__props","_ref","expose","emit","wrappedApp","loading","ref","watch","value","queryString","computed","URLSearchParams","toString","requestedLocation","iFrameLocation","currentLocation","frameId","appName","_value","logger","debug","request","current","loadTimeout","loadTimer","timerCount","container","loaderContainer","frameWrapper","externalFrame","iFrameBody","setIFrameSize","_ref2","width","height","iFrame","style","resizeObserver","ResizeObserver","entries","entry","target","contentRect","contentObserver","MutationObserver","info","emitLoaded","emitError","error","classList","toggle","Error","cause","hint","t","nextcloudUrl","window","location","protocol","host","iFrameUrl","iFrameWindow","contentWindow","iFrameDocument","contentDocument","href","search","Object","fromEntries","document","loadTimerHandler","undefined","querySelector","dispatchEvent","Event","setTimeout","onBeforeMount","onMounted","observe","onBeforeUnmount","disconnect","redaxoIFrame","__sfc","loadHandler","rcf","frameWindow","frameDocument","skin","rcmail","env","includes","querySelectorAll","forEach","el","remove","mainScreenElement","toplineHeight","getBoundingClientRect","toolbarHeight","newMainscreenTop","parseInt","top","removeTopLine","body","childList","subtree","_vm","this","_c","_self","_setup","_setupProxy","class","staticClass","_v","attrs","on"],"sourceRoot":""}