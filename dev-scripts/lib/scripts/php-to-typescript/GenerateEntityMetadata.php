#!/usr/bin/env php
<?php
/**
 * Some PHP utility functions for Nextcloud apps.
 *
 * @author Claus-Justus Heine <himself@claus-justus-heine.de>
 * @copyright 2020, 2021, 2022, 2023, 2024, 2025, 2026 Claus-Justus Heine
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

namespace OCA\RotDrop\DevScripts\PhpToTypeScript;

use ReflectionClass;
use UnexpectedValueException;

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\ConsoleOutputInterface;
use Symfony\Component\Console\Output\ConsoleSectionOutput;
use Symfony\Component\Process\Process;
use Symfony\Component\Process\Exception as ProcessExceptions;
use Symfony\Component\Console\Helper\ProgressBar;

use OCA\RotDrop\Toolkit\Traits\Constants;

/**
 * Generate enough meta-data for TypeScript to be able to define getters for
 * to-one and iterators for to-many associations.
 */
class GenerateEntityMetadata
{
  use \OCA\RotDrop\Toolkit\Traits\CamelCaseToDashesTrait;

  private array $entityMetaInfo = [];

  private string $entityNamespace;

  const FIELD_TYPE_OWNED = 'owned';
  const FIELD_TYPE_TO_ONE = 'to-one';
  const FIELD_TYPE_TO_MANY = 'to-many';

  const FIELD_TYPES = [
    self::FIELD_TYPE_OWNED,
    self::FIELD_TYPE_TO_MANY,
    self::FIELD_TYPE_TO_ONE,
  ];

  const META_DATA_NAME = 'EntityMetadata';
  const META_DATA_FORWARDER_FOLDER = 'Toolkit/Doctrine/ORM';

  /**
   * CTOR.
   *
   * @param string $devScriptsFolder The location of the main PHP script which
   * uses this script. Needed to determine the location of the ORM console
   * application.
   *
   * @param string $phpNamespacePrefix PHP-Namespace prefix to strip from the
   * start. Output will go to subdirectories according to the
   * remaining namespace.
   *
   * @param string $outputPrefix Output will start at this directory into a
   * directory formed by the full class-name of each entity (after stripping
   * the PHP namespace prefix).
   *
   * @param ConsoleOutputInterface $output
   */
  public function __construct(
    private string $devScriptsFolder,
    private string $phpNamespacePrefix,
    private string $outputPrefix,
    private ConsoleOutputInterface $output,
  ) {
  }

  /**
   * The purpose of this function is to generate a TypeScript snippet which
   * enables the TypeScript-modules generator to resolve the EntityMap type
   * and generate appropriate import statements for that type.
   *
   * @return string
   */
  public function exportEntityMap(): string
  {
    $entityMapNamespace = str_replace(Constants::PATH_SEP, '.', self::META_DATA_FORWARDER_FOLDER);

    return "declare namespace {$entityMapNamespace}." . self::META_DATA_NAME . " {
  // Ignore me: this is just here in order to inject the type for the sake
  // of namespace / type resolution during auto-generation of the php -> typescript
  // definition.
  export interface EntityMap {}
  export interface Type<N> { dummy: N }
}
";
  }

  /**
   * Generate TypeScript code. The return value is a TS dummy namespace which
   * enables the ts-modules-from-namespaces generator to resolve the
   * EntityMap interface.
   *
   * @return void
   */
  public function dumpTypeScriptData(): void
  {
    if (!($this->entityNamespace ?? null)) {
      throw new UnexpectedValueException('Entity-namespace is null, did you call ' . __CLASS__ . '::generateSparseMetadata()?');
    }
    $entityParentNamespace = substr($this->entityNamespace, 0, strrpos($this->entityNamespace, '\\'));
    $entityParentPath = str_replace('\\', Constants::PATH_SEP, $entityParentNamespace);
    $forwarderEntityPath = implode(Constants::PATH_SEP, array_fill(0, count(explode(Constants::PATH_SEP, self::META_DATA_FORWARDER_FOLDER)), '..'));
    $forwarderEntityPath .= "/{$entityParentPath}";

    $path = $this->outputPrefix . '/' . self::META_DATA_FORWARDER_FOLDER . '/' . self::META_DATA_NAME;
    mkdir($path, recursive: true);

    $forwarderEntityMetadataPath = self::META_DATA_NAME;
    $metadataForwarder = '// Automatically generated by ' . __CLASS__ . ", do not edit

import type { EntityReference, EntityReferenceCollection } from './EntitySerializer.ts';
";

    $metadataExports = [];
    $entityNameExports = [];
    $entityTypeExports = [];
    $entityTypeMap = '';
    $entityMetadataTypeMap = '';
    foreach ($this->entityMetaInfo as $entity => $entityInfo) {
      $upcaseEntity = strtoupper(self::camelCaseToDashes($entity, '_'));

      $metadataForwarder .= "import {
   type ENTITY_NAME as {$upcaseEntity}_ENTITY_NAME,
   type Entity as {$entity},
   type Metadata as {$entity}Metadata
} from './{$forwarderEntityMetadataPath}/{$entity}Metadata.ts';
";
      $metadataExports[] = "  type {$entity}Metadata,";
      $entityNameExports[] = "  type {$upcaseEntity}_ENTITY_NAME,";
      $entityTypeExports[] = "  type {$entity},";
      $entityTypeMap .= "[{$upcaseEntity}_ENTITY_NAME]: {$entity},
";
      $entityMetadataTypeMap .= "[{$upcaseEntity}_ENTITY_NAME]: {$entity}Metadata,
";

      $metadata = '// Automatically generated by ' . __CLASS__ . ", do not edit

export { type {$entity} as Entity } from '../{$forwarderEntityPath}/Entities.ts';

export const ENTITY_NAME = '{$entity}' as const;

const metadata = {
";
      foreach ($entityInfo as $field => $fieldInfo) {
        $metadata .= "  {$field}: {
";
        foreach ($fieldInfo as $key => $value) {
          if (is_string($value)) {
            $value = "'{$value}'";
          } elseif ($value === true) {
            $value= 'true';
          } elseif ($value === false) {
            $value = 'false';
          }
          $metadata .= "    {$key}: {$value} as const,
";
        }
        $metadata .= '  },
';
      }
      $metadata .= '};

export type Metadata = typeof metadata;

export default metadata;

';
      file_put_contents("{$path}/{$entity}Metadata.ts", $metadata);
    }

    // add a type map from entity names to entity types.
    $metadataForwarder .= "
export interface EntityMap {
{$entityTypeMap}}
";
    // add a type map from entity names to entity types.
    $metadataForwarder .= "
export interface EntityMetadataMap {
{$entityMetadataTypeMap}}
";

    // some complicate template stuff in order to get the entity-DTOs right.
    $metadataForwarder .= <<<EOF

export type EntityNames = keyof EntityMap|keyof EntityMetadataMap;
export type EntityFieldNames<N extends EntityNames> = keyof EntityMap[N]|keyof EntityMetadataMap[N];
type EntityFieldId<N extends EntityNames, F extends EntityFieldNames<N> = EntityFieldNames<N> > =
  F extends keyof EntityMetadataMap[N]
    ? ('id' extends keyof EntityMetadataMap[N][F]
        ? (EntityMetadataMap[N][F]['id'] extends boolean ? EntityMetadataMap[N][F]['id'] : never)
        : never)
    : never;
export type EntityAssociationFieldType<N extends EntityNames, F extends EntityFieldNames<N> = EntityFieldNames<N> > =
  F extends keyof EntityMetadataMap[N]
    ? ('type' extends keyof EntityMetadataMap[N][F]
        ? (EntityMetadataMap[N][F]['type'] extends keyof EntityMap ? EntityMetadataMap[N][F]['type'] : never)
        : never)
    : never;
export type EntityFieldMapping<N extends EntityNames, F extends EntityFieldNames<N> = EntityFieldNames<N> > =
  F extends keyof EntityMetadataMap[N]
    ? ('mapping' extends keyof EntityMetadataMap[N][F]
        ? EntityMetadataMap[N][F]['mapping']
        : never)
    : never;
export type EntityFieldNullable<N extends EntityNames, F extends EntityFieldNames<N> = EntitiyFieldNames<N> > =
  F extends keyof EntityMetadataMap[N]
    ? ('nullable' extends keyof EntityMetadataMap[N][F]
        ? EntityMetadataMap[N][F]['nullable']
        : never)
    : never;

export type EntityDto<N extends EntityNames> = {
  [K in EntityFieldNames<N>]: EntityFieldMapping<N, K> extends 'owned'
    ? (K extends keyof EntityMap[N] ? EntityMap[N][K] : never)
    : (EntityFieldMapping<N, K> extends 'to-one'
        ? EntityReference<EntityAssociationFieldType<N, K> >
        : EntityReferenceCollection<EntityAssociationFieldType<N, K> >);
};

export type EntityFieldMetadata<N extends EntityNames, F extends EntityFieldNames<N> = EntityFieldNames<N> > = {
  fieldName: F;
  id: EntityFieldId<N, F>;
  mapping: EntityFieldMapping<N, F>;
  type: EntityFieldType<N, F>;
  };

export type EntityId<N extends EntityNames> = {
  [F in keyof EntityMetadataMap[N] as ('id' extends keyof EntityMetadataMap[N][F] ? EntityMetadataMap[N][F]['id'] extends true ? F : never : never)]: unknown;
}

EOF;
    $metadataForwarder .= "
      export type EntityFieldMappingType = '";
    $metadataForwarder .= implode("'|'", self::FIELD_TYPES);
    $metadataForwarder .= "';
";

    foreach ([$metadataExports, $entityNameExports, $entityTypeExports] as $exports) {
      sort($exports);
      $exports = implode("\n", $exports);
      $metadataForwarder .= "
export {
{$exports}}

";
    }

    file_put_contents($path . '.ts', $metadataForwarder);
  }

  /**
   * Run the ORM cli commands and form an array of meta-data information.
   *
   * @return array
   */
  public function generateSparseMetadata(): array
  {
    $entityNames = [];
    $this->entityMetaInfo = [];

    $headerSection = $this->output->section();
    $headerSection->setMaxHeight(2);
    $textSection = $this->output->section();
    $textSection->setMaxHeight(5);
    $progressSection = $this->output->section();
    $progressBar = new ProgressBar($progressSection);
    $warningsSection = $this->output->section();

    $ormCliCmd = $this->devScriptsFolder . Constants::PATH_SEP . 'orm-cmd.php';

    // --format=json not understood here.
    $ormCliProcess = new Process([
      $ormCliCmd,
      'orm:info',
    ]);

    $headerSection->writeln('<info>' . 'Fetching list of entities ...' . '</>');
    $ormCliProcess->run();
    $rawEntities = $ormCliProcess->getOutput();
    $numberOfLines = substr_count($rawEntities, "\n");
    $progressBar->start($numberOfLines);
    $ormFile = fopen('php://temp', 'r+');
    fputs($ormFile, $rawEntities);
    rewind($ormFile);
    /* discard */ fgets($ormFile, 4096);
    $line = fgets($ormFile, 4096);
    while ($line !== false) {
      $line = trim($line);
      if (str_starts_with($line, '[OK]')) {
        $entity = trim(substr($line, strlen('[OK]')));
        $textSection->writeln($entity);
        $entityNames[] = $entity;
      }
      $progressBar->advance();
      $line = fgets($ormFile, 4096);
    }
    sort($entityNames);

    $textSection->clear();
    $headerSection->writeln('<info>' . 'Obtaining metadata information ...' . '</>');
    $progressBar->start(count($entityNames));

    // Ok, now fetch the meta data. For implementing kind-of entity-repositories
    // (read-only) in the frontend we just need the information if a field is an
    // association, and if this is the case, whether it is to-one -- this yields a
    // simple getter -- or if it is to-may -- this yields an iterator.
    foreach ($entityNames as $entityName) {
      // $textSection->writeln('ENTITY ' . $entityName);
      $ormCliProcess = new Process([
        $ormCliCmd,
        '--format=json',
        'orm:mapping:describe',
        $entityName,
      ]);
      $ormCliProcess->run();
      if (!$ormCliProcess->isSuccessful()) {
        throw new UnexpectedValueException('ORM CLI process failed: ' . $ormCliProcess->getErrorOuput());
      }

      $metadataJson = $ormCliProcess->getOutput();

      $metadata = json_decode($metadataJson, true);

      if (!str_starts_with($entityName, $this->phpNamespacePrefix)
          || str_contains($entityName, 'Wrapped')) {
        $warningsSection->writeln('<error>' . "Entity {$entityName} has been skipped, not ours ..." . '</>');
        continue;
      }
      $shortName = new ReflectionClass($entityName)->getShortName();
      if (!($this->entityNamespace ?? null)) {
        // just assume all entities live in the same namespace ...
        $this->entityNamespace = trim(substr(substr($entityName, 0, -strlen($shortName) - 1), strlen($this->phpNamespacePrefix)), '\\');
        $headerSection->writeln('Entity-Namespace: ' . $this->entityNamespace);
      }
      // $textSection->writeln('NAMESPACE ' . $this->entityNamespace);
      $entityName = $shortName;
      // echo $entityName . PHP_EOL;
      // print_r($metadata);
      $metaInfo = [];
      foreach ($metadata['fieldMappings'] as $fieldName => $ownField) {
        $metaInfo[$fieldName] = [
          'fieldName' => $fieldName,
          'type' => $ownField['type'],
          'id' => !!$ownField['id'],
          'nullable' => !!$ownField['nullable'],
          'mapping' => self::FIELD_TYPE_OWNED,
        ];
      }
      foreach ($metadata['associationMappings'] as $fieldName => $associationField) {
        $nullable = false;
        if (str_contains($associationField['class'], 'ToOne')) {
          $multiplicity = self::FIELD_TYPE_TO_ONE;
          if (str_contains($associationField['class'], 'OwningSide')  || str_contains($associationField['class'], 'ManyToOne')) {
            foreach ($associationField['joinColumns'] as $joinColumn) {
              $nullable = !isset($joinColumn['nullable']) || $joinColumn['nullable'];
              break;
            }
            if (!empty($associationField['inversedBy']) && isset($this->entityMetaInfo[$associationField['targetEntity']])) {
              $this->entityMetaInfo[$associationField['targetEntity']][$associationField['inversedBy']]['nullable'] = $nullable;
            }
          } else {
            // we need to inspect the owning side
            if (!empty($associationField['mappedBy']) && isset($this->entityMetaInfo[$associationField['targetEntity']])) {
              $nullable = $this->entityMetaInfo[$associationField['targetEntity']][$associationField['mappedBy']]['nullable'];
            }
          }
        } else {
          $multiplicity = self::FIELD_TYPE_TO_MANY;
          $nullable = false; // this is always a collection
        }
        $targetEntity = new ReflectionClass($associationField['targetEntity'])->getShortName();
        $metaInfo[$fieldName] = [
          'fieldName' => $fieldName,
          'id' => !!$associationField['id'],
          'mapping' => $multiplicity,
          'type' => $targetEntity,
          'nullable' => $nullable,
        ];
      }
      $this->entityMetaInfo[$entityName] = $metaInfo;
      if ($this->output->getVerbosity() >= OutputInterface::VERBOSITY_VERBOSE) {
        $text = explode(PHP_EOL, $entityName . ': ' . print_r($metaInfo, true));
        foreach ($text as $line) {
          $textSection->writeln($line, options: OutputInterface::VERBOSITY_VERBOSE);
        }
      } else {
        $textSection->writeln($entityName);
      }
      $progressBar->advance();
    }

    return $this->entityMetaInfo;
  }
}
